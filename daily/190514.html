<html>
<head>
  <title>Evernote Export</title>
  <basefont face="Arial" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/308297 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Arial;
      font-size: 11pt;
    }
  </style>
</head>
<body>
<a name="1342"/>

<div>
<span><div><div>注意只有1个或者2个元素时候；</div><div>Principles of Binary Search</div><ol><li><div>we must guarantee that the search space decreases over time (after each iteration)</div></li><li><div>we must guarantee that the target (if exists) cannot be ruled out accidentally, when we change the value of left or right (it is critical to define the rule about how to move the range for search)</div></li></ol><div>easy变种：</div><div>二维数组： [[1,2,3,4],[5,6,7,8],[9,10,11,12]]  find target == 7</div><div>思路：始终用index L = 0 ， R = 3 * 4 - 1 = 11 (or generally, m * n - 1); </div><div>Mid = ( 0 + 11 ) / 2 or left + (left - right)/2 均为向下取整，后者防止溢出。Mid 要map 回2D matrix：</div><div>    row = Mid / col_size</div><div>    col = Mid % col_size</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public boolean ifFind(int [] [] matrix, int target){</div><div>    if (matrix.length == 0 || matrix[0].length == 0)</div><div>        return false;</div><div>    int row = matrix.length;</div><div>    int col = matrix[0].length;</div><div>    int i = 0; // left</div><div>    int j = 0; //right</div><div>    while (i &lt;= j){</div><div>        int mid = i+(j-i)/2;</div><div>        int r = mid / col;</div><div>        int c = mid % col;</div><div>        if (matrix[r][c] == target)</div><div>            return true;</div><div>        else if(matrix[r][c] &gt; target)</div><div>            j = mid - 1;</div><div>        else</div><div>            i = mid + 1;</div><div>        }</div><div>    return false;</div><div>}</div></div><div><span style="color: rgb(51, 51, 51);"><font style="font-size: 11pt;">T = O(log(m*n))</font></span></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;">变种2：find the closest #</font></div><div><font style="font-size: 11pt;">只需变 left = mid; &amp; right mid;   不需+ - 1 因为+ - 1 可能会把想要的值 rule out 掉</font></div><div><font style="font-size: 11pt;">然后再进行post-process（剩下2个元素时）找出最近的；比较绝对值</font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;">变种3：find the first target</font></div><div><font style="font-size: 11pt;">how to return the index of the first occurrence of an element</font></div><div><font style="font-size: 11pt;">e.g. int a[7] = {4, 5, 5, 5, 5, 5, 5}; if target == 5; then index 1 return; if target == 10; then -1 return;</font></div><div><font style="font-size: 11pt;">termination condition: 当L 和R相邻时候跳出while loop，再判断哪个是最终答案（=post-processing)</font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;">变种3.1： find the last target</font></div><div><font style="font-size: 11pt;">只有if (a[mid] == target) 情况下与3不同：3的话 是 right = mid; 3.1是left=mid；</font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;">medium变种</font></div></div><div><font style="font-size: 11pt;">变4: closest k elements:</font></div><div><font style="font-size: 11pt;">how to return the index of k elements that are closest elements to the target.</font></div><div><font style="font-size: 11pt;">Soln 1 <b>(good but not optimal), see 变7</b></font></div><div>Step 1: run binary search until L = R -1, time = O(logn); </div><div><span>    we first move L and R by using binary search to make it close to the target number, until there are 2 or less elements  in between L &amp; R</span><br/></div><div>Step 2: 中心开花， L-- or R++ k 个元素， time=O(k)</div><div>total = O(log n + k), if k ~ n total = O(k)</div><div><br/></div><div>变种5： smallest element that is larger than target</div><div>变3.1的再变而已：就是find B</div><div>sssssmall eeeequal <b>B</b>bbbbbiger</div><div>if input[m] == s; L = M+1;</div><div>if input[m] == e; L = M+1;</div><div>if input[m] == b, R = M;</div><div><br/></div><div>Hard 变种：</div><div>变种6：k-th smallest in two sorted arrays</div><div>how to return the index of k elements that are closest elements to the target.</div><div><br/></div><div><span>    6</span>.1 two sorted int arrays, how to find median of the two arrays (跟6.2是同一个题)</div><div><span>    6.2 </span>two sorted int arrays, how to find the k-th smallest element from them<br/></div><div>6.2解题思路：</div><div>先找k/2 再找k/4 ，k/8...</div><div>1.先比较A[k/2] 与 B[k/2] 的大小，假如X &lt; Y 即我们找到了前k/2个数都在A上，（找到后每次删除其k/2 并放到result中）</div><div><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>     k/2</span><br/></div><div>A[] = <font style="color: rgb(255, 0, 0);">xxxxxxxxxxX</font>xxxxxxxxxxx<span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    </span><span>    k/2-th Smallest e.g. k = 1000</span></div><div>B[] = <font style="color: rgb(45, 79, 201);">yyyyyyyyyyY</font>yyyyyyyyyyy</div><div><font style="font-size: 11pt;"><span>    </span><span>    </span><span>    </span><span>    </span><span>    <span>    </span>k/2</span><br/></font></div><div><font style="font-size: 11pt;">2.<span>  再比较A[k/4]与 B[k/4]（也是k(space)/2）的大小（基于X&lt;Y在1），假如 X&gt;Y, 我们就再找到4/k个数在B上 </span></font></div><div><font style="font-size: 11pt;"><span>  </span><span>    </span><span>    </span><span>    </span><span>    </span><span>   start k/4</span></font></div><div>A[] = <font style="color: rgb(214, 214, 214);">xxxxxxxxxxX</font><font style="color: rgb(227, 0, 0);">xxxX</font>xxxxxxx                                    k/2-th Smallest e.g. k(space) = k/2 = 500</div><div>B[] = <font style="color: rgb(45, 79, 201);">yyyY</font>yyyyyyYyyyyyyyyyyy</div><div><span style="font-size: 11pt;">    </span><span style="font-size: 11pt;">   start</span><span style="font-size: 11pt;"> k/4</span><span style="font-size: 11pt;">    </span><span style="font-size: 11pt;">   </span><span style="font-size: 11pt;">k/2</span></div><div><font style="font-size: 11pt;"><br/></font></div><div>A[] = <span style="color: rgb(214, 214, 214);">xxxxxxxxxxX</span><span style="color: rgb(227, 0, 0);">xxX</span>xxxxxxxx                                    k/2-th Smallest e.g. k(space) = k/2 = 250</div><div>B[] = <font style="color: rgb(214, 214, 214);">yyyY</font><font style="color: rgb(45, 79, 201);">yyY</font>yyyYyyyyyyyyyyy</div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;">k/2 + k/4 + ... =k-1</font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private int kth(int [] a, int aleft, int[] b, int bleft, int k){</div><div><span>    // base case</span><br/></div><div><span><span>    if (aleft &gt;= a.length)</span><br/></span></div><div><span><span>    </span><span>    return b[bleft + k -1];</span><br/></span></div><div><span><span>    if (bleft &gt;= b.lenght)</span><br/></span></div><div><span><span>    </span><span>    return a[aleft + k -1];</span><br/></span></div><div><span><span>    if (k==1)</span><br/></span></div><div><span><span>    <span>    retun Math.min(a[aleft], b[bleft]);</span></span><br/></span></div><div><span><br/></span></div><div><span>    // since index starts from left, the k/2-th element should be <b>left + k/2 -1</b><b><br/></b></span></div><div><span><b>   </b> int amid = aleft + k/2 -1;<br/></span></div><div><span><span>    int bmid = bleft + k/2 -1;</span><br/></span></div><div><span><span>    // if a.size too small, then remove elements from b first.</span><br/></span></div><div><span><span>    int aval = amid &gt;= a.length? Integer.MAX_VALUE : a[amid];</span><br/></span></div><div><span>    </span>int bval = bmid &gt;= b.length? Integer.MAX_VALUE : b[bmid];</div><div><span>    </span><br/></div><div><span><span>    if(aval &lt;= bval)</span><br/></span></div><div><span><span>    </span><span>    return kth(a, amid + 1, b, bleft, k-k/2);</span><br/></span></div><div><span><span>    else</span><br/></span></div><div><span><span>    <span>    return kth(a, aleft, b, bmid + 1, k-k/2);</span></span><br/></span></div><div>}<span>   </span></div></div><div><font style="font-size: 11pt;">T = log(k)</font></div><div><font style="font-size: 11pt;"><br/></font></div><div><br/></div><div>变种7：k-th closest element</div><div>(变4 2nd soln)</div><div>Step1: 同变4 step1</div><div>Step2：把这一个array 分成左右两个arrays（并不需要真的new两个array）,然后用变6.2方法</div><div><br/></div><div>T =O( log(n) + log(k) )-&gt;O( log(n))</div><div><font style="font-size: 11pt;"><br/></font></div><div><br/></div><div>变8：Binary search with unknown size</div><div>given a sorted array with unknown size, how to determine whether a number in it or not.</div><div>e.g. dictionary[x] = {1 3 5 7 ....1001... 100000000000001...},</div><div>target = 9999,</div><div>Assumption if input[index] == null then we know the size of dictionary is &lt; index;</div><div><br/></div><div>Soln: </div><div>step 1: run step_size = 2* step_size; until we find out we have jumped out of the border </div><div>O(log2(n))    -- log以2为底</div><div>1.由于给了这个assumption所以我们可以先搜寻边界：每次扩大2倍（第n次扩大2^n倍）直到null时候边界出来了（还可以每次扩大后对比target，若这次刚扩大完边界已经比target大，即可停止</div><div>step 2：L = 0, R = step_size; binary search</div><div>O(log2(n))</div><div>2.用binary search 回溯target</div><div><br/></div><div><font style="font-size: 11pt;">question: why not jump 10 times more each time?</font></div><div><font style="font-size: 11pt;">当面试时被问到这个问题的时候，不要太快做回答做决定，可以跟面官说：I am not sure right now but let me analysis with you,...although use 10 times allow us jump out faster to reache the border than 2 times, it will also slower to jump in using binary search than 2 times. so it is hard to say from this point of view. </font></div><div><font style="font-size: 11pt;">let's take a look at this way, for 10 times jump out is O(log_10(n)) + jump in O(log_2(10n)) and for 2 times is O(log_2(n)) + O(log_2(2n)). 2为底增长得比较快，假如n趋向无穷还是10倍增长好</font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;">工业级：</font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;"><br/></font></div><div><br/></div></span>
</div></body></html> 